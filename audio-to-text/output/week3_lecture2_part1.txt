in this lecture we're going to look at some of the more traditional softer process models next week was it into the agile methodology I'll have some additional supplemental videos that will go over the to you and do some basic comparison so some of the things that you'll see today you'll see a little bit about again and the next lecture in addition to the discussion of traditional process models were also going to do an overview of how organizations are evaluated and assessed this will be the second video Associated to this lecture let's first get started with understanding what a process model actually is
during our discussion of building a system we defined as a software development process a process model has a similar definition with four areas that must be fully understood one the set of tasks that need to be performed needs to be defined to the input to an output from each task needs to be established and noun 3 the preconditions impose conditions for each task to take place needs to be defined and for the sequence of flow of these tasks also needs to be determined
the goal of the softer process follows to provide guidance for systematically coordinating and controlling the tasks that must be performed in order to achieve the end product
 all right process model is used for the purpose of coordinating and controlling what if I happen to be the only person working on the project or maybe I'm working with only one other person is there actually a requirement for having a model that we follow I mean it's just either myself or the two of us and I would hope that I would be working with someone that I get along with and we don't but heads up very often but there are processes needed or not actually depends if the software development process is viewed only as a coordinating and controlling agent so there's no need to because there's only one person or you and the other person however if the process is viewed as a prescriptive road map for generating various immediately so here were talking about user manuals test cases and design documents then even a one-person software development process may need a process
 all of us have already gone through several programming courses one graduates going to the field or maybe even if you're already in the field as developers are there will be even if it wasn't your intention many students who graduate with a computer networking option have a plan to do just stopped however I've seen many students who have gone through this option and the interview for the position of really like it so that is why they start with Coating in our classes and in our professions when we're left alone and when I say we are referring to us as programmers we turn to go straight into the implementation of a solution in other words we go straight to coating now I try to encourage students to flowchart things and maybe 3 some Sudafed first but in reality those that was a very small number so the process that we go through is that we get our problem with code compile and then if there's a problem with it and apologize
 we have no heirs once our program can pause we run unit tests with sometimes will show us. We just solved the problem that gives us the wrong answer because it didn't fully logically understand the problem statement to begin with so it might have some more changes to me and eventually we get to the point where we release our cuz this process is referred to as a code and fix model
 I couldn't fix model may work when working Solo or with another person but as we have previously stated projects don't remain simple when they become larger and more complex there is much more that must be taken into consideration and we must carefully examine the additional tasks and roles that the additional team members will impact in the past or sometimes when you do work on something simple the requirements may not all be present and when it comes to testing well that will change if the requirements end up changing as a system of project is being worked on and the client decides to add more to it or take away from it and the caseworker project has become more complex it is much more important to that we have our process model clearly defined
 as more people participate in software projects better coordination is introduced the tasks in the process the relationship among them and the flow of these tasks become better defined as software Engineers gained more experience different models other than the code and fix it were introduced to self concerns that were present today there's an understanding that there is no one process model that will fit all the saucer projects that exist or will exist in the future
 there are four traditional process models that we're going to discuss all of this for models go further beyond the code and fix it model because now I was one of the first sin and packaging I remember as we have also discussed so many of the failures or unsuccessful systems and projects are caused by issues with requirements so it must have some type of formal process and place the four process models that we're going to discuss today are the waterfall model model spiral model in the rational unified process model abbreviated by its acronym of r u p
 which of these models have something specific that a coach with the waterfall model is one
 for when there is no process in place the incremental we are looking at the decomposition of a larger system spiral we focus on risk management and rup which looks at issues of multiple development and management issues which will lead us into the discussion of evaluating and assessing the process models the first let's discuss these a little bit more. Since there is not anyone model for specific projects that each of these models can be and has been adapted and modified to fit different situation so things are not set in stone
 the waterfall model is probably the oldest process model that has been publicized the model has a process represented by a task that occur sequentially one after the other with the output from one task dropping into the new task has and put as shown in the figure here this is how the name waterfall came about the waterfall model is one that is not usually used as often anymore the main reason is that once you start the process you must go through its entirety a traditional waterfall model does not provide the opportunity for you to find something wrong and then be able to backtrack of the stuff you can do you must go all the way before you're able to go back to the beginning and start working your way down to fix whatever the issue was there for this model is terrible to use if you have a client who has not provided you with an exact set of requirements if the client changes their requirement
 that will mean that you will have to redesign redeveloping retest which results and more money spent the other downfall to the waterfall model is that we previously discussed that user interaction can either make or break our project software
 now at the requirements are fully specified and there are going to be no changes to them than the waterfall model has some positive aspects the fastest at the requirements are fully specified we know that before we ever get into integration must have the requirements check our design documented implementation completed and tests have been verified and validated for implementation at this point we can integrate the whole thing and ship it off we know that the outfit from one States is going to be the info for the night and we will always know where it is because we don't deviate from the flow with all of these stages
 there needs to be that needs to be completed before being able to proceed to the next we can see that there is a lot of documentation going on there is of course the requirements than you have your design documented unless previously stated we must designer test cases for Barbie Clements and those two have to be documented with all of these documents the waterfall model has become known as the document driven approach to software development is the waterfall model and realities is first model to be followed to provide us with something and something is always better than nothing based on being able to follow this model there was a focus on the process and saucer quality problems could be identified and play Space is a way for other models to be introduced that would resolve some of the problems that were identified within this model
 as we haven't made a way to ride our programming courses and possibly our work is that no matter sociation of problem it's always easier that when it's something that we divide and conquer able to take a complex problem remember complex means increased size and difficulty in being able to solve and breaking it down into smaller tasks will make it easier to work with since we are able to solve for the smaller components first and then we can infer mentally and I sure didn't leave bring all of it together that is what we do with the incremental model many times has an income in a model not only are we able to resolve or develops the smaller components and later bring them together but there can also be overlap where multiple components can be worked on at same time I'll have to be integrated and then tested as a hole in a final System test the income in a model provides a certain amount of risk containment if anyone component ran into trouble the other components are still
 able to continue the development independently
 she was a different way to follow the incremental model since we are working based on components which is the income in a model it means that we could have multiple releases release one piece into a second release that has another piece at which would add another until dawn because of this opportunity and of the perspective for the incremental model is to first of all to software that contains the most of the required functionality listen to the uses and Customs from now point you add a little more functionality to each release this allows for you to give feedback so that changes can be made for the upcoming releases if required utilizing the incremental model in this fashion makes it more relatable to an evolutionary product development the number of releases for a software project will depend on the nature and goal of the project although it releases independently built there is a link between releases because the existing design and code of the previous releases the basis upon which future releases are built now
 this picture here there is some overlapping that takes place between a releases and then we come to the question of how much of it can be overlapped well that also depends on how much information is required for One release to another so there are things that we can't actually fully determined before getting started since we don't know ahead of time what the feedback will be from each release
 does next models of spiral model this model is the one that is going to have a focus on risk management the spiral model is another model that takes on The evolutionary approach of development because this model has an emphasis in the reduction of risk and saucer developments the model is known as a risk driven development process what it does. It provides software while reducing the project risk as the project goes through the cycles of development there are four quadrants and the spiral model trucks were sold through the forefathers who go as identify the objects Alternatives or constraints for each cycle of the Spiral evaluate to the alternatives to the objectives and constraints and Performing the stats for many of the wrist or identified and evaluated depending on the amount
 type of identified risks developed a prototype more detailed evaluation and evolutionary development or some other stuff to further reduce the risk of achieving the detectives on the other hand if the risk is substantially reduces The Next Step may be to just do the task as required to design or code in for validate of the objectives and plan for the next cycle a very important step of the cycle is the review of our activities and products completed in the cycle by all the major stakeholders involved in the project this ensures that all participants are continually committed to the project and the approach that will take place with the next phase of the project through iterations there are several convenient features built into it these features include
 it allows alternative and evolutionary approaches to all activities based on the amount of risk involved and the model does not preclude is a network of an earlier activity if a better alternative or a new rest as identified I'm sorry not in that work for the Erie working so the model of the stop preclude the reworking of an earlier activity of a better alternative or a new risk is identified
 there is a small catch when it comes to the spiral model the spiral model aims at risk reduction however one of the risks of the Spiral model is the Reliance on risk assessment expertise not all software Engineers are trained or experience in Risk identification and risk analysis
 the last traditional model we're going to discuss today is Saturday rational unified process or are you piece the framework for this model is driven by three concepts one use case these are used to describe any interaction between a software system and anything external such as user of the system architecture architecture is going to describe the static and dynamic
 aspects of the overall system with the more important aspects highlighted in the less important details left out there is the adjective and incremental process of the first adoration includes the use case or requirements representing the increment or slices of product the second generation would handle all the most important risks and the chosen increment and successive iterations with that build upon the results of the previous the phase is associated the rup model are not named according to the activities the phases may have multiple activities are there any liquor is there are four faces to the rup in these are Inception elaboration construction and transition Associated activities are listen to the lot of faces usually viewed as to start the beginning of it all this is when the product is still in an early stage of uncertainty
 Alisal ideas being developed as well that's what we are doing our product is built coded and tested during construction lastly the product is released to a group of users for additional testing and depending on the results corrections may have to be made in the add the product is released to the General Public
 what's a majority of the processes that we have discussed we have at some point touched base as to what might be an input to the activity and what is a result from that activity this is really how to size with the process models that follow a sequencing and coordinating of activities there are not very many guidelines as far as how much activity should be performed in other words when is the activity actually completed so here we're going to discuss entry and exit criteria in relation to activities and then we'll end this part of the lecture and pick up with the next where we discuss evaluation and assessment so prior to being able to perform any activity we have to ask for what conditions must be present or have been met for an activity to be to be able to answer this question we must have a description of required artifacts required people required tools and we have to understand the activity that is going to be
 been there for the activity must be to find along with each activity we also have to determine when something is considered to be completed so what is completed actually mean well when it comes to software engineering in the discussion of Entry criteria it means that all specifications have been reviewed by the customer and other stakeholders all exceptions found during the review our change of the modified specifications are accepted by all parties these two conditions must be completed and Matt moved from tacit ask only when these three are completed and met for requirement specification are they considered to have met the entry criteria for the design tasks and this works through all of the different tasks a process goes through all right so we know the requirements for entry to process deer activity what about being able to exit
 to know when it's actually completed so the main purpose of the eyes of criteria is to describe the artifacts that must be available for the next activity you want to be sure that you have clear definitions of the artifact and also the following one that all artifacts have been reviewed to all or some pre-specified percentage of the errors are corrected three the downstream activities have accepted and the greens to the artifacts
 as with everything else that's the criteria should be specified ahead of time. This is where I'm going to stop this lecture video there is a part to where we are covering process assessment model please be sure to also watch it
 if you have questions concerns or comments as always please let me
