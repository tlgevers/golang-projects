in this lecture We are continuing from having spoken about creating a program and now we are going to start discussing building a system
 so when it comes to building our system our problem statement gets much larger than that of a simple program as we saw in the first lecture and this one we're going to go into discussing the difference between running program and building system and going to discuss some of the concerns associated with Building A system that contains multiple component anything from just a few components to maybe hundreds or thousands of components becomes more ubiquitous the development of systems involving software is also going to become more complex these problems common multiple levels of breadth and depth
 so as you can see in the image here we have a problem that we start with that increases in size and complexity able to transform that problem into a solution is going to be our efforts due to the increase in size and complexity and lastly of course the solution itself will also be larger in size and complexity
 the breadth issue address numbers their number of things involved when it comes to the breadth issue of complexity so we need to look at the major functions that we're working with these teachers within each functional area interfaces to any other internal or external system what what are the users who are the users are they going to be simultaneously using the system and then types of data and data structures that are used to think about your homework assignment know if you haven't taken a look at it at this may not make much sense but once you do it well what would happen if the list of numbers on your input file was increased to a couple of hundred to thousands of numbers profile and then you have trillions of files to work with
 when it comes to depth of complexity this is going to address the issue of linkage and the relationship among the items are so the linkages May either be through the sharing of data or through the transfer of control or so these relationships baby hierarchical they may be sequential and might be related to recursive functions or some other form
 here we take a look at a simple example and one that increases in size and complexity so in the simple case that's found on the left we have three major segments we have a start process we have three normal tasks and then we have a stop process the figure on the right the number of normal tasks is increased from 3 to 5 with the addition of a wait for Signal task and a tossed a to there's also a new decision task represented by the diamond shaped figure in the center to decision task has greatly increased the number of paths or choices and that's that causes the increase of complexity in addition the complexity is further and start by introducing a loop relationship with the decisions task there are many more
 interactions involved in a loop or a repeat type relationship which is more complex than the straight forward sequential relationship among the tasks that are portrayed on the left image
 when we go from the simple program to the more complex the basic issue is how to handle the pieces parts and relationships one common solution we're going to discuss three is based on the concept of divide and conquer the natural questions how we divide a large complex problem and its solution into smaller part is more difficult to then it's the key to attacking large and complex problems is to consider some form of simplification through different activities such as decomposition modularization separation or incremental iterations
 aside from simplification there are problems related to technology and Tool considerations that also needs to be addressed with a large complex system you're more than likely not working alone you probably have a programming language in school preference and sold the other developers that are also working on this problem not only will developers have different levels of experiences a different languages but they may also have different levels of experience with the different possibilities to be used within the project a common development language development in their choices that are related to Database Network middleware and other technical components such as code Version Control all of these must be agreed upon by all parties involved in building as
 boarding the complex Software System
 when you work as a single programmer all the problem you may not have to follow a process or methodology now there are times when you still may want to have a process in mind to be able to document some of the decisions that you have made in case if in the future someone else has to work with modified or maintaining what you have developed every decision made will have some type of rationale that you chose are influenced your decision of these are things that should be documented when you are working with multiple developers or team members you should have a process or methodology that you follow a software development processes needed to guide and coordinate the group of people that are working on the project method used for specific tasks along with the entire development process must be agreed to you by the group of people involved in the project
 the process was invented to coordinate and manage complex projects involving many people there are continuous improvements and new proposals being made to the software development process
 but no one has proposed for the complete process to be eliminated the softer process is commonly accepted that some process must exist to help corny as complex as successful software project traditional software process models and emerging process models such as the ads all methods are topics that we will cover in weeks to come
 let's take him to this generation the example that's County are we have common tasks often performed in software development and support each task appears as an independent to item and each one has a question of what is expected and how we perform it when several individuals are involved in software development support there has to be a clear understanding of the overlap and starting condition one way to do this is through the concept of incremental development and continuous integration the cost of the of incremental development and continuous integration to be staying here so what exactly is meant when we say softer integration it's a process of linking together individually tested units into a coordinated whole system it is something that has been practices the 1970s this methodology is actually gaining popularity due to the agile methodologies which again we're going to discuss and waited to come
 you'll notice of the bottom of the figure that are foxes depicting a simple process of test 6 and a great however the simple representation is actually the stuff the simple cycle that we're shown actually requires a description of a methodology that answers all the questions count here to there be separated or independent test groups how should problems be reported it to him how much information must accompany a problem with Ford who decides in the property of the problem has problem fixed return should all problems be fixed what should we do with non fixed problems and how are fixes integrated back to the system don't even mind that everything must be agreed upon by the group that is working together and these are just some of the questions that must be determined and worked out for 8th edition of the process
 in addition to technical implications large and complex systems also require an awareness of non technical issues diesel correspond to effort estimation and schedules and different assignment set of communications for small and fair simple software project that involves a team of one two three people the effort estimation is scheduling of the project it's relatively easy to the functional and nonfunctional requirements to the projects are fewer in Denver at complexity for call flags and large systems capturing an understanding the requirements alone can be overwhelming estimating the total effort and coming up with a reliable project schedule under the statistical condition is one of the main reasons behind so many software project failures the inaccurate a free estimates and schedules for large complex systems are often extremely optimistic and aggressive this place is unrealistic expectation on both the customers and the suppliers
 the system when it comes to having multiple people on a project we have to take into consideration the assignment of tasks and communication just having two different people to different tasks such as puffing integration or tool support requires more understanding of the skills of the people involved as specific tasks they have to perform the assignment of the most effective improperly skilled people to the right tasks requires a deeper level of granularity and finer level of scheduling another related problem with the increase in Personnel is the problem with communication we're going to discuss that a little more with the next blind
 the fishing here shows how Maxim communication pass increase as the number of participants increase the nose in the figure represent the people and the lines represent communication pop the number of possible communication path more than doubles when the number of team members has increased from 4 to 6 in general the number of communication past 4 en people is the sum of N -1 where some is the arithmetics some function as 1 2 3 all the way to end the smallest increase from a four-person team to a 12-person team would increase the potential number of communication past from 6 to 66 at Rippling of a small team would increase the potential communication path by more than 10 times associated with this increases the share number of communication path
 is the chance of an air communication communication among team members may be a serious problem especially if the message is critical organizational structures of people need to be put in place to reduce the complexity and increase the number of correct communication
 a critical concern for large complex system is the upward scaling of the needed process of the design structure and contents of the product and of the required for Snell the opposite direction is the concern of downlord scaling of the same parameters for Stifler's to stop going to briefly discuss details of process product design and personnel management we will go into details in later weeks when it comes to process in the past on reviews instructions testing and meeting that were part of the process large corporations signed up for expensive quality assurance and measurement effort these efforts were designed to prevent detect and correct problems in return improving the quality of software and increasing the productivity of the software developers extensive metric programs were put in place to measure pulse
 Louis and productivity I'm posting the article on blackboard that is a reading assignment for everyone that you read it as there will be questions on the exam from it now development and support process in recent years there has been a movement to simplify the process and cost to take center stage in the software industry product to just be the executor and realities there are many artifacts that must be produced as part of the software product these artifacts range from Carmen's document to functional test scenarios users and customers may require manual teacher education and product support which are all also considered part of the software product simply delivering a package of executable code is not enough every products that is created with a larger
 will more than likely be expected to have a long lifespan and therefore it will need to be designed for changes and said that it is easily maintained lastly there is the human element which is the crucial component in the development and support of software in many ways the software industry is still labor-intensive is the study of software engineering must include the issues of coordinating people's activities and management skills part of the discussion on coordinating software Engineers activities is embedded in the process of discussion
 a large and vital part of coordinating software Personnel lies in the organization structure and strength of communication among the various pasticcio
 that wraps things up in our discussion about building a system
 next week's lecture will be covering engineering of software and software process model supposed to have any questions concerns or comments about anything of this lecture please be sure to send me an e-mail give me a phone call let me know
